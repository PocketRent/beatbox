#!/usr/bin/env hhvm
<?hh

require __DIR__ . '/../xhp/init.php';

function makeMap() {
	$lookIn = __DIR__ . '/../..';

	$map = [];

	global $base;
	$base = realpath(__DIR__ . '/../..');

	foreach(glob($lookIn, GLOB_ONLYDIR) as $dir) {
		$map = array_merge_recursive($map, handleDir($dir));
	}


	$export_map = var_export($map, true);

	$date = date(DATE_ISO8601);

	$php = <<<PHP
<?hh
// Generated by build/classmap at $date
\$map = $export_map;

PHP;

	file_put_contents(__DIR__ . '/../conf/map.php', $php);

	return $map;
}

function handleDir($dir) {
	global $base;
	$dir = realpath($dir);
	if(!$dir) return [];

	$map = [
		'class' => [],
		'function' => [],
		'constant' => [],
		'type' => []
	];

	foreach(glob($dir . '/*') as $file) {
		if($file[0] == '.') continue;
		if(is_dir($file)) {
			$map = array_merge_recursive($map, handleDir($file));
		} else {
			$filename = str_replace($base, '', $file);
			$filename = ltrim($filename, '/');

			$contents = file_get_contents($file);
			// Pull out namespace
			if(preg_match('#^namespace +(\S+);#mi', $contents, $match)) {
				$ns = $match[1] . '\\';
			} else {
				$ns = '';
			}

			$class = false;

			if(preg_match_all('#^(?:(?:abstract|final) *)?(?:class|interface|trait) +(\S+)[ \n]#mi', $contents, $matches, PREG_SET_ORDER)) {
				foreach($matches as $match) {
					if($match[1][0] == ':') {
						$match[1] = :x:base::element2class(substr($match[1], 1));
					}
					$name = strtolower($ns . $match[1]);
					$map['class'][$name] = $filename;
				}
				$class = true;
			}

			if (preg_match_all('#^function\s+([\w_]+)#mi', $contents, $matches, PREG_SET_ORDER)) {
				foreach($matches as $match) {
					$map['function'][strtolower($match[1])] = $filename;
				}
			}

			if (preg_match_all('#^\s*define\([\'"](\S+)[\'"]#mi', $contents, $matches, PREG_SET_ORDER)) {
				foreach ($matches as $match) {
					$map['constant'][$match[1]] = $filename;
				}
			}
		}
	}

	return $map;
}

if (isset($argc)) {
	makeMap();
}
